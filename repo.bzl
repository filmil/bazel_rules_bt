_CPU_TO_ARCH = {
    "amd64": "x86_64",
}


def _get_tool_label(ctx):
    """Obtains the label of the multitool binary target to use for downloading
    the files.

    This performs a function similar to toolchain resolution in ordinary rules.
    Except repo rules don't have this API, so we have to make do.

    """
    arch = _CPU_TO_ARCH[ctx.os.arch]
    os = ctx.os.name
    tool_label = Label(
        "".join([
            "@@rules_multitool++multitool+multitool.rain.{os}_{arch}",
            "//tools/rain:{os}_{arch}_executable"]).format(os=os,arch=arch))
    return tool_label



def _bt_file_impl(ctx):
    quiet = ctx.attr.quiet
    uri = ctx.attr.uri
    tool_path = str(ctx.path(_get_tool_label(ctx)))
    filename = ctx.attr.file or ctx.attr.name
    args = [
        tool_path, "download",
        "--torrent", uri,
        "--resume", "/tmp/_bazel.{}.resume".format(ctx.attr.name)]
    result = ctx.execute(args, quiet = quiet, timeout = ctx.attr.timeout)

    ctx.file(
        "BUILD.bazel",
        """# Autogenerated, do not edit.

# @<repo_name>//:file
filegroup(
    name = "file",
    srcs = [
        "{name}",
    ],
)
exports_files([
    "{name}",
])
""".format(name=filename),
    )


bt_file = repository_rule(
    implementation = _bt_file_impl,
    attrs = {
        "uri": attr.string(
            doc = "The torrent URI to download the file from.",
            mandatory = True,
        ),
        "timeout": attr.int(
            doc = "The timeout in seconds for the download.",
            default = 200000,
        ),
        "file": attr.string(
            doc = "The name of the file to use for the downloaded file.",
        ),
        "integrity": attr.string(
            doc = "The integrity signature of this file",
            mandatory = True,
        ),
        "quiet": attr.bool(
            default = True,
            doc = "Whether to omit printing download progress",
        ),
    },
)
