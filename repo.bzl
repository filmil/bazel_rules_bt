_CPU_TO_ARCH = {
    "amd64": "x86_64",
}


_COMMON_ATTRS = {
        "timeout": attr.int(
            doc = "The timeout in seconds for the download.",
            default = 200000,
        ),
        "integrity": attr.string(
            doc = "The integrity signature of this file",
            mandatory = True,
        ),
        "quiet": attr.bool(
            default = True,
            doc = "Whether to omit printing download progress",
        ),
        "file": attr.string(
            doc = "The name of the file to use for the downloaded file.",
        ),
}


def _get_tool_label(ctx):
    """Obtains the label of the multitool binary target to use for downloading
    the files.

    This performs a function similar to toolchain resolution in ordinary rules.
    Except repo rules don't have this API, so we have to make do.

    """
    arch = _CPU_TO_ARCH[ctx.os.arch]
    os = ctx.os.name
    tool_label = Label(
        "".join([
            "@@rules_multitool++multitool+multitool.rain.{os}_{arch}",
            "//tools/rain:{os}_{arch}_executable"]).format(os=os,arch=arch))
    return tool_label


def _bt_common(ctx):
    quiet = ctx.attr.quiet
    uri = ctx.attr.uri
    if uri.startswith("@@//:"):
        uri = "/".join([str(ctx.workspace_root), uri[5:]])
    tool_path = str(ctx.path(_get_tool_label(ctx)))
    filename = ctx.attr.file or ctx.attr.name
    ctx.file("config.yaml", """#
resume-on-startup: true
dht-enabled: true
""")
    args = [
        tool_path, "download",
        "--config", "config.yaml",
        "--torrent", uri,
        "--resume", "/tmp/_bazel.{}.resume".format(ctx.attr.name)]
    result = ctx.execute(args, quiet = quiet, timeout = ctx.attr.timeout)
    return filename


def _bt_file_impl(ctx):
    filename = _bt_common(ctx)
    ctx.file(
        "BUILD.bazel",
        """# Autogenerated, do not edit.

# @<repo_name>//:file
filegroup(
    name = "file",
    srcs = [
        "{name}",
    ],
)
exports_files([
    "{name}",
])
""".format(name=filename),
    )



bt_file = repository_rule(
    implementation = _bt_file_impl,
    attrs = _COMMON_ATTRS | {
        "uri": attr.string(
            doc = "The torrent URI to download the file from.",
            mandatory = True,
        ),
    },
)


def _bt_archive_impl(ctx):
    filename = _bt_common(ctx)
    if ctx.attr.extract:
        ctx.extract(filename, strip_prefix=ctx.attr.strip_prefix)
    ctx.file("BUILD.bazel", ctx.attr.build_file_content.format(name=filename))


bt_archive = repository_rule(
    implementation = _bt_archive_impl,
    attrs = _COMMON_ATTRS | {
        "uri": attr.string(
            doc = "The torrent URI to download the file from.",
            mandatory = True,
        ),
        "build_file_content": attr.string(
            doc = "The content of the build file to place in the repo",
            mandatory = True,
        ),
        "strip_prefix": attr.string(
            doc = "The prefix (directory) within the archive to strip away",
            default = '',
        ),
        "extract": attr.bool(
            default = True,
            doc = "Whether to extract the downloaded torrent (torrent with multiple files may not need this)",
        ),
    },
)
